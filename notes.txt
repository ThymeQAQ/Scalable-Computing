//main.py
import sys
import requests
import argparse
from node import Node
import os
from urllib.parse import urljoin
import signal
import time

def get_registry_url():
    return os.getenv('REGISTRY_URL', 'http://localhost:5000')

def register_node_with_server(node_id, node_ip, node_port):
    registry_url = get_registry_url()
    try:
        response = requests.post(urljoin(registry_url, "/register"), json={
            "node_id": node_id,
            "node_ip": node_ip,
            "node_port": node_port
        })
        if response.status_code == 201:
            print(response.json()['message'])
        else:
            print(f"[ERROR] Registration failed: {response.text}")
            sys.exit(1)
    except requests.exceptions.ConnectionError:
        print(f"[ERROR] Can't connect to the registry server {registry_url}")
        sys.exit(1)
    except Exception as e:
        print(f"[ERROR] Unexpected error during registration: {e}")
        sys.exit(1)

def get_registered_nodes():
    registry_url = get_registry_url()
    try:
        response = requests.get(urljoin(registry_url, "/nodes"))
        if response.status_code == 200:
            return response.json()
        print(f"[ERROR] Failed to get nodes: {response.text}")
        return {}
    except requests.exceptions.ConnectionError:
        print(f"[ERROR] Can't connect to the registry server {registry_url}")
        return {}
    except Exception as e:
        print(f"[ERROR] Unexpected error while getting nodes: {e}")
        return {}

def signal_handler(signum, frame):
    print("\n[INFO] Shutting down node...")
    if hasattr(signal_handler, 'node'):
        signal_handler.node.stop()
    sys.exit(0)

def main():
    parser = argparse.ArgumentParser(description='Start a network node')
    parser.add_argument('node_id', help='Unique identifier for the node')
    parser.add_argument('node_ip', help='IP address for the node')
    parser.add_argument('node_port', type=int, help='Port number for the node')
    args = parser.parse_args()

    # Register signal handlers
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    print(f"[INFO] Attempting to register node {args.node_id} with the registry server...")
    register_node_with_server(args.node_id, args.node_ip, args.node_port)

    print("\n[INFO] Current registered nodes:")
    registered_nodes = get_registered_nodes()
    for nid, (ip, port) in registered_nodes.items():
        print(f"Node ID: {nid}, IP: {ip}, port: {port}")

    try:
        node = Node(args.node_id, args.node_ip, args.node_port)
        signal_handler.node = node  # Store node reference for clean shutdown
        node.start()

        print(f"\n[INFO] {args.node_id} is ready. Use 'send_message.py' to send message.")
        print(f"[INFO] Connect to this node using address: {args.node_ip}:{args.node_port}")
        print("[INFO] Press Ctrl+C to stop the node")

        # Keep the main thread alive
        while True:
            time.sleep(1)

    except Exception as e:
        print(f"[ERROR] Failed to start node: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()

//message.py
import json
import time
import base64
import os
from enum import Enum

class MessageType(Enum):
    DIRECT = "direct"
    BROADCAST = "broadcast"
    IMAGE = "image"

class Message:
    MAX_IMAGE_SIZE = 5 * 1024 * 1024  # 5MB limit for images
    
    def __init__(self, sender_id, message_type, content, target_node=None, file_info=None):
        self.sender_id = sender_id
        if isinstance(message_type, str):
            message_type = MessageType(message_type)
        self.message_type = message_type
        self.content = content
        self.target_node = target_node
        self.timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        self.file_info = file_info

    @classmethod
    def create_image_message(cls, sender_id, image_path, target_node=None):
        # Check if file exists
        if not os.path.exists(image_path):
            raise FileNotFoundError(f"Image file not found: {image_path}")
            
        # Check file size
        file_size = os.path.getsize(image_path)
        if file_size > cls.MAX_IMAGE_SIZE:
            raise ValueError(f"Image size exceeds maximum limit of {cls.MAX_IMAGE_SIZE/1024/1024}MB")
            
        # Read and encode image
        with open(image_path, 'rb') as f:
            image_data = base64.b64encode(f.read()).decode('utf-8')
            
        file_info = {
            'filename': os.path.basename(image_path),
            'size': file_size,
            'format': os.path.splitext(image_path)[1][1:].lower()
        }
            
        return cls(
            sender_id=sender_id,
            message_type=MessageType.IMAGE,
            content=image_data,
            target_node=target_node,
            file_info=file_info
        )

    def to_json(self):
        return json.dumps({
            "sender_id": self.sender_id,
            "message_type": self.message_type.value,
            "content": self.content,
            "target_node": self.target_node,
            "timestamp": self.timestamp,
            "file_info": self.file_info
        })

    @staticmethod
    def from_json(json_str):
        data = json.loads(json_str)
        return Message(
            sender_id=data["sender_id"],
            message_type=MessageType(data["message_type"]),
            content=data["content"],
            target_node=data.get("target_node"),
            file_info=data.get("file_info")
        )

//node.py
import socket
import threading
import time
import os
import base64
from message import Message, MessageType

class Node:
    def __init__(self, node_id, host, port, max_connections=5):
        self.node_id = node_id
        self.host = host
        self.port = port
        self.max_connections = max_connections
        self.connections = {}
        self.is_running = False
        self.server_socket = None
        self._lock = threading.Lock()

    def start(self):
        try:
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_socket.bind((self.host, self.port))
            self.server_socket.listen(self.max_connections)
            self.is_running = True
            self.server_thread = threading.Thread(target=self.server_loop)
            self.server_thread.start()
            print(f"[INFO] Node {self.node_id} started successfully on {self.host}:{self.port}")
        except Exception as e:
            print(f"[ERROR] Failed to start node {self.node_id}: {e}")
            raise

    def stop(self):
        print(f"[INFO] Stopping node {self.node_id}...")
        self.is_running = False
        
        if self.server_socket:
            try:
                self.server_socket.close()
            except Exception as e:
                print(f"[ERROR] Error closing server socket: {e}")

        with self._lock:
            for node_id, conn in self.connections.items():
                try:
                    conn.close()
                    print(f"[INFO] Closed connection to node {node_id}")
                except Exception as e:
                    print(f"[ERROR] Error closing connection to {node_id}: {e}")
            self.connections.clear()

        if hasattr(self, 'server_thread'):
            try:
                self.server_thread.join(timeout=5)
                print("[INFO] Server thread stopped successfully")
            except Exception as e:
                print(f"[ERROR] Error stopping server thread: {e}")

    def server_loop(self):
        while self.is_running:
            try:
                self.server_socket.settimeout(1.0)
                try:
                    conn, addr = self.server_socket.accept()
                    conn.settimeout(60)
                    client_thread = threading.Thread(target=self.handle_connection, args=(conn, addr))
                    client_thread.start()
                except socket.timeout:
                    continue
                except Exception as e:
                    if self.is_running:
                        print(f"[ERROR] Error accepting connection: {e}")
            except Exception as e:
                if self.is_running:
                    print(f"[ERROR] Error in server loop: {e}")
                break
        print("[INFO] Server loop ended")

    def handle_connection(self, conn, addr):
        node_id = None
        try:
            # Receive sender ID with proper handling
            sender_id_data = b""
            while b'\n' not in sender_id_data:
                chunk = conn.recv(1024)
                if not chunk:
                    return
                sender_id_data += chunk
            
            node_id = sender_id_data.split(b'\n')[0].decode().strip()
            if not node_id:
                print("[WARNING] Received empty node ID, closing connection")
                return

            with self._lock:
                self.connections[node_id] = conn
            print(f"[INFO] Connection established with {node_id} from {addr}")
            
            while self.is_running:
                try:
                    # Read message length first (fixed header size)
                    header = b""
                    remaining = 8
                    while remaining > 0:
                        chunk = conn.recv(remaining)
                        if not chunk:
                            return
                        header += chunk
                        remaining -= len(chunk)
                        
                    message_length = int.from_bytes(header, byteorder='big')
                    
                    # Read the full message
                    message_data = b""
                    while len(message_data) < message_length:
                        chunk_size = min(8192, message_length - len(message_data))
                        chunk = conn.recv(chunk_size)
                        if not chunk:
                            return
                        message_data += chunk
                    
                    # Process the message
                    message = Message.from_json(message_data.decode())
                    
                    if message.message_type == MessageType.IMAGE:
                        self._handle_image_message(message)
                    else:
                        self._handle_text_message(message)
                        
                except socket.timeout:
                    continue
                except Exception as e:
                    print(f"[ERROR] Error receiving message from {node_id}: {e}")
                    break
        finally:
            if node_id:
                with self._lock:
                    self.connections.pop(node_id, None)
            conn.close()
            print(f"[INFO] Connection closed for {node_id if node_id else 'unknown node'}")

    def _handle_text_message(self, message):
        """Handle received text message"""
        msg_type = "broadcast" if message.message_type == MessageType.BROADCAST else "direct"
        print(f"[INFO] Received {msg_type} message from {message.sender_id}")
        print(f"[INFO] Content: {message.content}")
        
        # For broadcast messages, verify this node is not the sender before displaying
        if message.message_type == MessageType.BROADCAST and message.sender_id != self.node_id:
            print(f"[INFO] Broadcast message from {message.sender_id}: {message.content}")
        # For direct messages, verify this node is the intended recipient
        elif message.message_type == MessageType.DIRECT and message.target_node == self.node_id:
            print(f"[INFO] Direct message from {message.sender_id}: {message.content}")

    def _handle_image_message(self, message):
        """Handle received image message"""
        try:
            if not message.file_info:
                print("[ERROR] Missing file information in image message")
                return
                
            # Create images directory if it doesn't exist
            os.makedirs('received_images', exist_ok=True)
            
            # Generate unique filename
            filename = f"received_images/{message.sender_id}_{int(time.time())}_{message.file_info['filename']}"
            
            # Decode and save image
            image_data = base64.b64decode(message.content)
            with open(filename, 'wb') as f:
                f.write(image_data)
                
            print(f"[INFO] Received image from {message.sender_id}, saved as {filename}")
            print(f"[INFO] Image size: {message.file_info['size']/1024:.2f}KB")
            
        except Exception as e:
            print(f"[ERROR] Failed to handle image message: {e}")

//register_server.py
from flask import Flask, request, jsonify
from flask_cors import CORS
import threading
import time

app = Flask(__name__)
CORS(app)

class Registry:
    def __init__(self):
        self.nodes = {}
        self.lock = threading.Lock()

    def register_node(self, node_id, node_ip, node_port):
        with self.lock:
            self.nodes[node_id] = (node_ip, node_port)

    def remove_node(self, node_id):
        with self.lock:
            if node_id in self.nodes:
                del self.nodes[node_id]

    def get_nodes(self):
        with self.lock:
            return dict(self.nodes)

registry = Registry()

@app.route('/register', methods=['POST'])
def register_node():
    try:
        data = request.json
        if not all(k in data for k in ['node_id', 'node_ip', 'node_port']):
            return jsonify({"error": "Missing required fields"}), 400

        node_id = data['node_id']
        node_ip = data['node_ip']
        node_port = data['node_port']

        registry.register_node(node_id, node_ip, node_port)
        print(f"[INFO] Node {node_id} registered successfully at {node_ip}:{node_port}")
        return jsonify({"message": f"Node {node_id} registered successfully"}), 201

    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/nodes', methods=['GET'])
def list_nodes():
    try:
        return jsonify(registry.get_nodes()), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Start the registry server')
    parser.add_argument('--host', default='0.0.0.0', help='Host to bind to')
    parser.add_argument('--port', type=int, default=5000, help='Port to bind to')
    args = parser.parse_args()

    print(f"[INFO] Registry server starting on http://{args.host}:{args.port}")
    app.run(host=args.host, port=args.port)

if __name__ == '__main__':
    main()


//send_message.py
import sys
import socket
import requests
import time
import argparse
import os
from urllib.parse import urljoin
from message import Message, MessageType

def get_registry_url():
    return os.getenv('REGISTRY_URL', 'http://localhost:5000')

def get_all_nodes():
    registry_url = get_registry_url()
    try:
        response = requests.get(urljoin(registry_url, "/nodes"))
        if response.status_code == 200:
            return response.json()
        print(f"[ERROR] Failed to get nodes: {response.text}")
        return {}
    except requests.exceptions.ConnectionError:
        print(f"[ERROR] Can't connect to the registry server at {registry_url}")
        return {}
    except Exception as e:
        print(f"[ERROR] Unexpected error while getting nodes: {e}")
        return {}

def send_to_node(sender_id, target_ip, target_port, message_obj, retries=3, retry_delay=1.0):
    sock = None
    for attempt in range(retries):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            print(f"[DEBUG] Connecting to {target_ip}:{target_port}, attempt {attempt + 1}/{retries}")
            sock.connect((target_ip, target_port))

            # Send sender ID with newline
            sender_id_bytes = f"{sender_id}\n".encode()
            print(f"[DEBUG] Sending sender ID: {sender_id}")
            sock.sendall(sender_id_bytes)
            
            # Prepare message data
            message_data = message_obj.to_json().encode()
            message_length = len(message_data)
            print(f"[DEBUG] Message length: {message_length} bytes")
            print(f"[DEBUG] Message content: {message_data.decode()}")

            # Send message length as 8-byte header
            length_header = message_length.to_bytes(8, byteorder='big')
            print(f"[DEBUG] Sending length header: {len(length_header)} bytes")
            sock.sendall(length_header)
            
            # Send message data
            total_sent = 0
            while total_sent < message_length:
                chunk_size = min(8192, message_length - total_sent)
                sent = sock.send(message_data[total_sent:total_sent + chunk_size])
                if sent == 0:
                    raise RuntimeError("Socket connection broken")
                total_sent += sent
                print(f"[DEBUG] Sent {total_sent}/{message_length} bytes")
            
            # Wait briefly to ensure data is sent
            time.sleep(0.1)
            print("[DEBUG] Message sent successfully")
            return True

        except Exception as e:
            print(f"[ERROR] Send failed: {str(e)}")
            if sock:
                sock.close()
            if attempt < retries - 1:
                print(f"[INFO] Retrying in {retry_delay} seconds...")
                time.sleep(retry_delay)
                continue
            return False
        finally:
            if sock:
                sock.close()

def broadcast_message(sender_id, content, exclude_nodes=None):
    if exclude_nodes is None:
        exclude_nodes = set()
    
    nodes = get_all_nodes()
    if not nodes:
        print("[ERROR] No nodes available for broadcast")
        return False

    message = Message(
        sender_id=sender_id,
        message_type=MessageType.BROADCAST,
        content=content,
        target_node=None
    )
    
    print(f"[DEBUG] Created broadcast message: {message.to_json()}")
    
    success_count = 0
    total_nodes = len(nodes) - len(exclude_nodes)

    print(f"[INFO] Broadcasting message to {total_nodes} nodes...")
    
    for node_id, (ip, port) in nodes.items():
        if node_id in exclude_nodes:
            continue

        print(f"[INFO] Sending to node {node_id} at {ip}:{port}...")
        if send_to_node(sender_id, ip, port, message):
            success_count += 1
            print(f"[INFO] Successfully sent to {node_id}")
        else:
            print(f"[ERROR] Failed to send to {node_id}")

    print(f"[INFO] Broadcast complete. Successfully sent to {success_count}/{total_nodes} nodes")
    return success_count > 0

def direct_message(sender_id, target_node, content):
    nodes = get_all_nodes()
    if target_node not in nodes:
        print(f"[ERROR] Target node {target_node} not found in registry")
        return False

    message = Message(
        sender_id=sender_id,
        message_type=MessageType.DIRECT,
        content=content,
        target_node=target_node
    )
    
    print(f"[DEBUG] Created direct message: {message.to_json()}")
    
    target_ip, target_port = nodes[target_node]
    print(f"[INFO] Sending direct message to {target_node} at {target_ip}:{target_port}...")
    
    success = send_to_node(sender_id, target_ip, target_port, message)
    
    if success:
        print(f"[INFO] Message successfully sent to {target_node}")
    else:
        print(f"[ERROR] Failed to send message to {target_node}")
    
    return success

def send_image(sender_id, target_node, image_path):
    """Send an image to a specific node"""
    nodes = get_all_nodes()
    if target_node not in nodes:
        print(f"[ERROR] Target node {target_node} not found in registry")
        return False

    try:
        message = Message.create_image_message(sender_id, image_path, target_node)
        target_ip, target_port = nodes[target_node]
        
        print(f"[INFO] Sending image {image_path} to {target_node}...")
        print(f"[INFO] File size: {message.file_info['size']/1024:.2f}KB")
        
        success = send_to_node(sender_id, target_ip, target_port, message)
        
        if success:
            print(f"[INFO] Image successfully sent to {target_node}")
        else:
            print(f"[ERROR] Failed to send image to {target_node}")
        
        return success

    except Exception as e:
        print(f"[ERROR] Failed to send image: {e}")
        return False

def main():
    parser = argparse.ArgumentParser(description='Send messages or images to nodes')
    parser.add_argument('sender_id', help='ID of the sending node')
    parser.add_argument('--broadcast', '-b', action='store_true', 
                      help='Broadcast message to all nodes')
    parser.add_argument('--target', '-t', help='Target node ID for direct message')
    parser.add_argument('--message', '-m', help='Message content')
    parser.add_argument('--image', '-i', help='Path to image file to send')
    parser.add_argument('--exclude', '-e', nargs='+', help='Node IDs to exclude from broadcast')
    
    args = parser.parse_args()

    if args.broadcast and args.target:
        print("[ERROR] Cannot specify both broadcast and target node")
        sys.exit(1)

    if not args.broadcast and not args.target:
        print("[ERROR] Must specify either broadcast (-b) or target node (-t)")
        sys.exit(1)

    if bool(args.message) == bool(args.image):
        print("[ERROR] Must specify either message (-m) or image (-i), but not both")
        sys.exit(1)

    print(f"[DEBUG] Starting with sender_id: {args.sender_id}")
    print(f"[DEBUG] Message content: {args.message}")
    print(f"[DEBUG] Target: {args.target}")
    print(f"[DEBUG] Broadcast: {args.broadcast}")

    success = False
    if args.image:
        if args.broadcast:
            print("[ERROR] Image broadcast is not supported")
            sys.exit(1)
        success = send_image(args.sender_id, args.target, args.image)
    elif args.broadcast:
        exclude_nodes = set(args.exclude) if args.exclude else set()
        success = broadcast_message(args.sender_id, args.message, exclude_nodes)
    else:
        success = direct_message(args.sender_id, args.target, args.message)

    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

