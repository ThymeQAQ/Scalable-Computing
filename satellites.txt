//registry_server.py
from flask import Flask, request, jsonify
from flask_cors import CORS
import threading
import time

app = Flask(__name__)
CORS(app)

class Registry:
    def __init__(self):
        self.nodes = {}
        self.lock = threading.Lock()

    def register_node(self, node_id, node_ip, node_port):
        with self.lock:
            self.nodes[node_id] = (node_ip, node_port)

    def remove_node(self, node_id):
        with self.lock:
            if node_id in self.nodes:
                del self.nodes[node_id]

    def get_nodes(self):
        with self.lock:
            return dict(self.nodes)

registry = Registry()

@app.route('/register', methods=['POST'])
def register_node():
    try:
        data = request.json
        if not all(k in data for k in ['node_id', 'node_ip', 'node_port']):
            return jsonify({"error": "Missing required fields"}), 400

        node_id = data['node_id']
        node_ip = data['node_ip']
        node_port = data['node_port']

        registry.register_node(node_id, node_ip, node_port)
        print(f"[INFO] Node {node_id} registered successfully at {node_ip}:{node_port}")
        return jsonify({"message": f"Node {node_id} registered successfully"}), 201

    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/nodes', methods=['GET'])
def list_nodes():
    try:
        return jsonify(registry.get_nodes()), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Start the registry server')
    parser.add_argument('--host', default='0.0.0.0', help='Host to bind to')
    parser.add_argument('--port', type=int, default=5000, help='Port to bind to')
    args = parser.parse_args()

    print(f"[INFO] Registry server starting on http://{args.host}:{args.port}")
    app.run(host=args.host, port=args.port)

if __name__ == '__main__':
    main()


//satellite.py
import math
import time
import threading
from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Optional, Tuple
from node import Node
from message import Message, MessageType

@dataclass
class Position:
    latitude: float
    longitude: float
    altitude: float  # in kilometers
    timestamp: float

class SatelliteStatus(Enum):
    ACTIVE = "active"
    HANDOVER = "handover"
    OFFLINE = "offline"

class LEOSatelliteNode(Node):
    def __init__(self, node_id: str, host: str, port: int, 
                 initial_position: Position,
                 orbital_period: float = 90,  # minutes
                 max_connections: int = 5):
        super().__init__(node_id, host, port, max_connections)
        
        # Satellite-specific attributes
        self.position = initial_position
        self.orbital_period = orbital_period
        self.status = SatelliteStatus.ACTIVE
        self.isl_connections: Dict[str, Tuple[str, int]] = {}  # Inter-Satellite Links
        self.ground_stations: Dict[str, Position] = {}
        self.handover_lock = threading.Lock()
        
        # Performance metrics
        self.latency_history: List[float] = []
        self.bandwidth_usage: Dict[str, float] = {}
        
        # Start satellite position update thread
        self.position_thread = threading.Thread(target=self._update_position)
        self.position_thread.daemon = True
        self.position_thread.start()

    def _update_position(self):
        """Updates satellite position based on orbital parameters"""
        while self.is_running:
            current_time = time.time()
            
            # Calculate new position based on orbital mechanics
            # This is a simplified circular orbit calculation
            orbit_progress = (current_time % (self.orbital_period * 60)) / (self.orbital_period * 60)
            
            # Update position (simplified circular orbit)
            self.position.longitude = (orbit_progress * 360 - 180) % 360
            self.position.timestamp = current_time
            
            # Check for handover requirements
            self._check_handover_needed()
            
            time.sleep(1)  # Update position every second

    def _check_handover_needed(self):
        """Determines if handover is needed based on position and coverage"""
        with self.handover_lock:
            if self.status != SatelliteStatus.HANDOVER:
                for gs_id, gs_pos in self.ground_stations.items():
                    if self._calculate_distance(self.position, gs_pos) > self._max_communication_range():
                        self._initiate_handover(gs_id)

    def _initiate_handover(self, ground_station_id: str):
        """Initiates handover procedure for a ground station"""
        self.status = SatelliteStatus.HANDOVER
        
        try:
            # Find nearby satellites that can take over
            nearby_satellites = self._find_nearby_satellites()
            if not nearby_satellites:
                print(f"[WARNING] No suitable satellites found for handover of {ground_station_id}")
                return
            
            # Select best satellite for handover
            target_satellite = self._select_best_satellite(nearby_satellites)
            
            # Create handover message
            handover_msg = Message(
                sender_id=self.node_id,
                message_type=MessageType.HANDOVER,
                content={
                    "ground_station_id": ground_station_id,
                    "position": self.ground_stations[ground_station_id].__dict__
                },
                target_node=target_satellite
            )
            
            # Send handover request
            self._send_handover_request(handover_msg)
            
        finally:
            self.status = SatelliteStatus.ACTIVE

    def _calculate_distance(self, pos1: Position, pos2: Position) -> float:
        """Calculate distance between two points using Haversine formula"""
        R = 6371  # Earth's radius in kilometers
        
        lat1, lon1 = math.radians(pos1.latitude), math.radians(pos1.longitude)
        lat2, lon2 = math.radians(pos2.latitude), math.radians(pos2.longitude)
        
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        
        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2
        c = 2 * math.asin(math.sqrt(a))
        
        return R * c

    def _max_communication_range(self) -> float:
        """Calculate maximum communication range based on altitude"""
        # Simplified calculation - actual range would depend on more factors
        return math.sqrt(2 * self.position.altitude * 6371)

    def handle_connection(self, conn, addr):
        """Override handle_connection to include satellite-specific handling"""
        try:
            # Add latency simulation for LEO environment
            simulated_latency = self._calculate_latency(addr)
            time.sleep(simulated_latency)
            
            # Call parent class handler
            super().handle_connection(conn, addr)
            
        except Exception as e:
            print(f"[ERROR] Satellite connection handler error: {e}")
        finally:
            self._update_connection_metrics(addr)

    def _calculate_latency(self, addr) -> float:
        """Calculate expected latency based on distance and orbital parameters"""
        # Simplified latency calculation
        base_latency = 0.02  # 20ms base latency
        distance_factor = 0.001  # 1ms per 1000km
        
        # Get peer position (if available)
        peer_position = self._get_peer_position(addr)
        if peer_position:
            distance = self._calculate_distance(self.position, peer_position)
            return base_latency + (distance * distance_factor)
        
        return base_latency

    def _update_connection_metrics(self, addr):
        """Update performance metrics for the connection"""
        current_time = time.time()
        
        # Record latency
        latency = self._calculate_latency(addr)
        self.latency_history.append(latency)
        
        # Keep only recent history
        if len(self.latency_history) > 1000:
            self.latency_history = self.latency_history[-1000:]

    def get_connection_stats(self) -> Dict:
        """Get current connection statistics"""
        return {
            "average_latency": sum(self.latency_history) / len(self.latency_history) if self.latency_history else 0,
            "active_connections": len(self.connections),
            "status": self.status.value,
            "position": self.position.__dict__,
            "isl_count": len(self.isl_connections)
        }

//node.py
import socket
import threading
import time
import os
import base64
from message import Message, MessageType

class Node:
    def __init__(self, node_id, host, port, max_connections=5):
        self.node_id = node_id
        self.host = host
        self.port = port
        self.max_connections = max_connections
        self.connections = {}
        self.is_running = False
        self.server_socket = None
        self._lock = threading.Lock()

    def start(self):
        try:
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_socket.bind((self.host, self.port))
            self.server_socket.listen(self.max_connections)
            self.is_running = True
            self.server_thread = threading.Thread(target=self.server_loop)
            self.server_thread.start()
            print(f"[INFO] Node {self.node_id} started successfully on {self.host}:{self.port}")
        except Exception as e:
            print(f"[ERROR] Failed to start node {self.node_id}: {e}")
            raise

    def stop(self):
        print(f"[INFO] Stopping node {self.node_id}...")
        self.is_running = False
        
        if self.server_socket:
            try:
                self.server_socket.close()
            except Exception as e:
                print(f"[ERROR] Error closing server socket: {e}")

        with self._lock:
            for node_id, conn in self.connections.items():
                try:
                    conn.close()
                    print(f"[INFO] Closed connection to node {node_id}")
                except Exception as e:
                    print(f"[ERROR] Error closing connection to {node_id}: {e}")
            self.connections.clear()

        if hasattr(self, 'server_thread'):
            try:
                self.server_thread.join(timeout=5)
                print("[INFO] Server thread stopped successfully")
            except Exception as e:
                print(f"[ERROR] Error stopping server thread: {e}")

    def server_loop(self):
        while self.is_running:
            try:
                self.server_socket.settimeout(1.0)
                try:
                    conn, addr = self.server_socket.accept()
                    conn.settimeout(60)
                    client_thread = threading.Thread(target=self.handle_connection, args=(conn, addr))
                    client_thread.start()
                except socket.timeout:
                    continue
                except Exception as e:
                    if self.is_running:
                        print(f"[ERROR] Error accepting connection: {e}")
            except Exception as e:
                if self.is_running:
                    print(f"[ERROR] Error in server loop: {e}")
                break
        print("[INFO] Server loop ended")

    def handle_connection(self, conn, addr):
        node_id = None
        try:
            # Receive sender ID with proper handling
            sender_id_data = b""
            while b'\n' not in sender_id_data:
                chunk = conn.recv(1024)
                if not chunk:
                    return
                sender_id_data += chunk
            
            node_id = sender_id_data.split(b'\n')[0].decode().strip()
            if not node_id:
                print("[WARNING] Received empty node ID, closing connection")
                return

            with self._lock:
                self.connections[node_id] = conn
            print(f"[INFO] Connection established with {node_id} from {addr}")
            
            while self.is_running:
                try:
                    # Read message length first (fixed header size)
                    header = b""
                    remaining = 8
                    while remaining > 0:
                        chunk = conn.recv(remaining)
                        if not chunk:
                            return
                        header += chunk
                        remaining -= len(chunk)
                        
                    message_length = int.from_bytes(header, byteorder='big')
                    
                    # Read the full message
                    message_data = b""
                    while len(message_data) < message_length:
                        chunk_size = min(8192, message_length - len(message_data))
                        chunk = conn.recv(chunk_size)
                        if not chunk:
                            return
                        message_data += chunk
                    
                    # Process the message
                    message = Message.from_json(message_data.decode())
                    
                    if message.message_type == MessageType.IMAGE:
                        self._handle_image_message(message)
                    else:
                        self._handle_text_message(message)
                        
                except socket.timeout:
                    continue
                except Exception as e:
                    print(f"[ERROR] Error receiving message from {node_id}: {e}")
                    break
        finally:
            if node_id:
                with self._lock:
                    self.connections.pop(node_id, None)
            conn.close()
            print(f"[INFO] Connection closed for {node_id if node_id else 'unknown node'}")

    def _handle_text_message(self, message):
        """Handle received text message"""
        msg_type = "broadcast" if message.message_type == MessageType.BROADCAST else "direct"
        print(f"[INFO] Received {msg_type} message from {message.sender_id}")
        print(f"[INFO] Content: {message.content}")
        
        # For broadcast messages, verify this node is not the sender before displaying
        if message.message_type == MessageType.BROADCAST and message.sender_id != self.node_id:
            print(f"[INFO] Broadcast message from {message.sender_id}: {message.content}")
        # For direct messages, verify this node is the intended recipient
        elif message.message_type == MessageType.DIRECT and message.target_node == self.node_id:
            print(f"[INFO] Direct message from {message.sender_id}: {message.content}")

    def _handle_image_message(self, message):
        """Handle received image message"""
        try:
            if not message.file_info:
                print("[ERROR] Missing file information in image message")
                return
                
            # Create images directory if it doesn't exist
            os.makedirs('received_images', exist_ok=True)
            
            # Generate unique filename
            filename = f"received_images/{message.sender_id}_{int(time.time())}_{message.file_info['filename']}"
            
            # Decode and save image
            image_data = base64.b64decode(message.content)
            with open(filename, 'wb') as f:
                f.write(image_data)
                
            print(f"[INFO] Received image from {message.sender_id}, saved as {filename}")
            print(f"[INFO] Image size: {message.file_info['size']/1024:.2f}KB")
            
        except Exception as e:
            print(f"[ERROR] Failed to handle image message: {e}")

//message.py
import json
import time
import base64
import os
from enum import Enum

class MessageType(Enum):
    DIRECT = "direct"
    BROADCAST = "broadcast"
    IMAGE = "image"

class Message:
    MAX_IMAGE_SIZE = 5 * 1024 * 1024  # 5MB limit for images
    
    def __init__(self, sender_id, message_type, content, target_node=None, file_info=None):
        self.sender_id = sender_id
        if isinstance(message_type, str):
            message_type = MessageType(message_type)
        self.message_type = message_type
        self.content = content
        self.target_node = target_node
        self.timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        self.file_info = file_info

    @classmethod
    def create_image_message(cls, sender_id, image_path, target_node=None):
        # Check if file exists
        if not os.path.exists(image_path):
            raise FileNotFoundError(f"Image file not found: {image_path}")
            
        # Check file size
        file_size = os.path.getsize(image_path)
        if file_size > cls.MAX_IMAGE_SIZE:
            raise ValueError(f"Image size exceeds maximum limit of {cls.MAX_IMAGE_SIZE/1024/1024}MB")
            
        # Read and encode image
        with open(image_path, 'rb') as f:
            image_data = base64.b64encode(f.read()).decode('utf-8')
            
        file_info = {
            'filename': os.path.basename(image_path),
            'size': file_size,
            'format': os.path.splitext(image_path)[1][1:].lower()
        }
            
        return cls(
            sender_id=sender_id,
            message_type=MessageType.IMAGE,
            content=image_data,
            target_node=target_node,
            file_info=file_info
        )

    def to_json(self):
        return json.dumps({
            "sender_id": self.sender_id,
            "message_type": self.message_type.value,
            "content": self.content,
            "target_node": self.target_node,
            "timestamp": self.timestamp,
            "file_info": self.file_info
        })

    @staticmethod
    def from_json(json_str):
        data = json.loads(json_str)
        return Message(
            sender_id=data["sender_id"],
            message_type=MessageType(data["message_type"]),
            content=data["content"],
            target_node=data.get("target_node"),
            file_info=data.get("file_info")
        )

//satellite_main.py
import sys
import requests
import argparse
from satellite import LEOSatelliteNode, Position, SatelliteStatus
import os
from urllib.parse import urljoin
import signal
import time
import math
import random

def generate_orbital_position(satellite_index: int, total_satellites: int) -> Position:
    """Generate initial orbital position for a satellite in a constellation"""
    # Distribute satellites evenly in a circular orbit
    angle = (360.0 / total_satellites) * satellite_index
    
    # Convert angle to radians
    rad = math.radians(angle)
    
    # Calculate position (simplified circular orbit)
    altitude = 550  # Typical Starlink altitude in km
    earth_radius = 6371  # Earth radius in km
    
    # Calculate latitude and longitude based on angle
    latitude = 53.0 * math.cos(rad)  # 53° orbital inclination like Starlink
    longitude = angle
    
    return Position(
        latitude=latitude,
        longitude=longitude,
        altitude=altitude,
        timestamp=time.time()
    )

def register_satellite_with_server(node_id, node_ip, node_port, position):
    registry_url = os.getenv('REGISTRY_URL', 'http://localhost:5000')
    try:
        response = requests.post(urljoin(registry_url, "/register"), json={
            "node_id": node_id,
            "node_ip": node_ip,
            "node_port": node_port,
            "satellite_data": {
                "latitude": position.latitude,
                "longitude": position.longitude,
                "altitude": position.altitude
            }
        })
        if response.status_code == 201:
            print(f"[SUCCESS] Satellite {node_id} registered successfully")
            print(response.json()['message'])
        else:
            print(f"[ERROR] Registration failed: {response.text}")
            sys.exit(1)
    except requests.exceptions.ConnectionError:
        print(f"[ERROR] Can't connect to the registry server {registry_url}")
        sys.exit(1)
    except Exception as e:
        print(f"[ERROR] Unexpected error during registration: {e}")
        sys.exit(1)

def get_registered_satellites():
    registry_url = os.getenv('REGISTRY_URL', 'http://localhost:5000')
    try:
        response = requests.get(urljoin(registry_url, "/nodes"))
        if response.status_code == 200:
            return response.json()
        print(f"[ERROR] Failed to get nodes: {response.text}")
        return {}
    except requests.exceptions.ConnectionError:
        print(f"[ERROR] Can't connect to the registry server {registry_url}")
        return {}
    except Exception as e:
        print(f"[ERROR] Unexpected error while getting nodes: {e}")
        return {}

def signal_handler(signum, frame):
    print("\n[INFO] Shutting down satellite node...")
    if hasattr(signal_handler, 'node'):
        signal_handler.node.stop()
    sys.exit(0)

def main():
    parser = argparse.ArgumentParser(description='Start a LEO satellite node')
    parser.add_argument('node_id', help='Unique identifier for the satellite')
    parser.add_argument('node_ip', help='IP address for the satellite node')
    parser.add_argument('node_port', type=int, help='Port number for the satellite node')
    parser.add_argument('--orbital-period', type=float, default=90, 
                       help='Orbital period in minutes (default: 90)')
    parser.add_argument('--constellation-size', type=int, default=5,
                       help='Total number of satellites in constellation (default: 5)')
    parser.add_argument('--satellite-index', type=int, required=True,
                       help='Index of this satellite in the constellation (0 to constellation_size-1)')
    
    args = parser.parse_args()

    # Register signal handlers
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # Generate initial orbital position
    initial_position = generate_orbital_position(
        args.satellite_index, 
        args.constellation_size
    )

    print(f"[INFO] Initializing satellite {args.node_id} at position: "
          f"lat={initial_position.latitude:.2f}°, "
          f"lon={initial_position.longitude:.2f}°, "
          f"alt={initial_position.altitude}km")

    # Register with registry server
    print(f"[INFO] Registering satellite {args.node_id} with registry server...")
    register_satellite_with_server(args.node_id, args.node_ip, args.node_port, initial_position)

    # Create and start satellite node
    try:
        satellite = LEOSatelliteNode(
            node_id=args.node_id,
            host=args.node_ip,
            port=args.node_port,
            initial_position=initial_position,
            orbital_period=args.orbital_period
        )
        signal_handler.node = satellite
        satellite.start()

        print(f"\n[INFO] Satellite {args.node_id} is operational")
        print(f"[INFO] Orbital period: {args.orbital_period} minutes")
        print(f"[INFO] Maximum connections: {satellite.max_connections}")
        print(f"[INFO] Status: {satellite.status.value}")
        print("[INFO] Press Ctrl+C to terminate the satellite")

        while True:
            time.sleep(5)  # Status update interval
            stats = satellite.get_connection_stats()
            print(f"\n[STATUS] Satellite {args.node_id}:")
            print(f"Position: lat={stats['position']['latitude']:.2f}°, "
                  f"lon={stats['position']['longitude']:.2f}°")
            print(f"Active connections: {stats['active_connections']}")
            print(f"Average latency: {stats['average_latency']*1000:.2f}ms")
            print(f"ISL connections: {stats['isl_count']}")
            print(f"Status: {stats['status']}")

    except Exception as e:
        print(f"[ERROR] Failed to start satellite: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()

//send_message.py
import sys
import socket
import requests
import time
import argparse
import os
from urllib.parse import urljoin
from message import Message, MessageType

def get_registry_url():
    return os.getenv('REGISTRY_URL', 'http://localhost:5000')

def get_all_nodes():
    registry_url = get_registry_url()
    try:
        response = requests.get(urljoin(registry_url, "/nodes"))
        if response.status_code == 200:
            return response.json()
        print(f"[ERROR] Failed to get nodes: {response.text}")
        return {}
    except requests.exceptions.ConnectionError:
        print(f"[ERROR] Can't connect to the registry server at {registry_url}")
        return {}
    except Exception as e:
        print(f"[ERROR] Unexpected error while getting nodes: {e}")
        return {}

def send_to_node(sender_id, target_ip, target_port, message_obj, retries=3, retry_delay=1.0):
    sock = None
    for attempt in range(retries):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            print(f"[DEBUG] Connecting to {target_ip}:{target_port}, attempt {attempt + 1}/{retries}")
            sock.connect((target_ip, target_port))

            # Send sender ID with newline
            sender_id_bytes = f"{sender_id}\n".encode()
            print(f"[DEBUG] Sending sender ID: {sender_id}")
            sock.sendall(sender_id_bytes)
            
            # Prepare message data
            message_data = message_obj.to_json().encode()
            message_length = len(message_data)
            print(f"[DEBUG] Message length: {message_length} bytes")
            print(f"[DEBUG] Message content: {message_data.decode()}")

            # Send message length as 8-byte header
            length_header = message_length.to_bytes(8, byteorder='big')
            print(f"[DEBUG] Sending length header: {len(length_header)} bytes")
            sock.sendall(length_header)
            
            # Send message data
            total_sent = 0
            while total_sent < message_length:
                chunk_size = min(8192, message_length - total_sent)
                sent = sock.send(message_data[total_sent:total_sent + chunk_size])
                if sent == 0:
                    raise RuntimeError("Socket connection broken")
                total_sent += sent
                print(f"[DEBUG] Sent {total_sent}/{message_length} bytes")
            
            # Wait briefly to ensure data is sent
            time.sleep(0.1)
            print("[DEBUG] Message sent successfully")
            return True

        except Exception as e:
            print(f"[ERROR] Send failed: {str(e)}")
            if sock:
                sock.close()
            if attempt < retries - 1:
                print(f"[INFO] Retrying in {retry_delay} seconds...")
                time.sleep(retry_delay)
                continue
            return False
        finally:
            if sock:
                sock.close()

def broadcast_message(sender_id, content, exclude_nodes=None):
    if exclude_nodes is None:
        exclude_nodes = set()
    
    nodes = get_all_nodes()
    if not nodes:
        print("[ERROR] No nodes available for broadcast")
        return False

    message = Message(
        sender_id=sender_id,
        message_type=MessageType.BROADCAST,
        content=content,
        target_node=None
    )
    
    print(f"[DEBUG] Created broadcast message: {message.to_json()}")
    
    success_count = 0
    total_nodes = len(nodes) - len(exclude_nodes)

    print(f"[INFO] Broadcasting message to {total_nodes} nodes...")
    
    for node_id, (ip, port) in nodes.items():
        if node_id in exclude_nodes:
            continue

        print(f"[INFO] Sending to node {node_id} at {ip}:{port}...")
        if send_to_node(sender_id, ip, port, message):
            success_count += 1
            print(f"[INFO] Successfully sent to {node_id}")
        else:
            print(f"[ERROR] Failed to send to {node_id}")

    print(f"[INFO] Broadcast complete. Successfully sent to {success_count}/{total_nodes} nodes")
    return success_count > 0

def direct_message(sender_id, target_node, content):
    nodes = get_all_nodes()
    if target_node not in nodes:
        print(f"[ERROR] Target node {target_node} not found in registry")
        return False

    message = Message(
        sender_id=sender_id,
        message_type=MessageType.DIRECT,
        content=content,
        target_node=target_node
    )
    
    print(f"[DEBUG] Created direct message: {message.to_json()}")
    
    target_ip, target_port = nodes[target_node]
    print(f"[INFO] Sending direct message to {target_node} at {target_ip}:{target_port}...")
    
    success = send_to_node(sender_id, target_ip, target_port, message)
    
    if success:
        print(f"[INFO] Message successfully sent to {target_node}")
    else:
        print(f"[ERROR] Failed to send message to {target_node}")
    
    return success

def send_image(sender_id, target_node, image_path):
    """Send an image to a specific node"""
    nodes = get_all_nodes()
    if target_node not in nodes:
        print(f"[ERROR] Target node {target_node} not found in registry")
        return False

    try:
        message = Message.create_image_message(sender_id, image_path, target_node)
        target_ip, target_port = nodes[target_node]
        
        print(f"[INFO] Sending image {image_path} to {target_node}...")
        print(f"[INFO] File size: {message.file_info['size']/1024:.2f}KB")
        
        success = send_to_node(sender_id, target_ip, target_port, message)
        
        if success:
            print(f"[INFO] Image successfully sent to {target_node}")
        else:
            print(f"[ERROR] Failed to send image to {target_node}")
        
        return success

    except Exception as e:
        print(f"[ERROR] Failed to send image: {e}")
        return False

def main():
    parser = argparse.ArgumentParser(description='Send messages or images to nodes')
    parser.add_argument('sender_id', help='ID of the sending node')
    parser.add_argument('--broadcast', '-b', action='store_true', 
                      help='Broadcast message to all nodes')
    parser.add_argument('--target', '-t', help='Target node ID for direct message')
    parser.add_argument('--message', '-m', help='Message content')
    parser.add_argument('--image', '-i', help='Path to image file to send')
    parser.add_argument('--exclude', '-e', nargs='+', help='Node IDs to exclude from broadcast')
    
    args = parser.parse_args()

    if args.broadcast and args.target:
        print("[ERROR] Cannot specify both broadcast and target node")
        sys.exit(1)

    if not args.broadcast and not args.target:
        print("[ERROR] Must specify either broadcast (-b) or target node (-t)")
        sys.exit(1)

    if bool(args.message) == bool(args.image):
        print("[ERROR] Must specify either message (-m) or image (-i), but not both")
        sys.exit(1)

    print(f"[DEBUG] Starting with sender_id: {args.sender_id}")
    print(f"[DEBUG] Message content: {args.message}")
    print(f"[DEBUG] Target: {args.target}")
    print(f"[DEBUG] Broadcast: {args.broadcast}")

    success = False
    if args.image:
        if args.broadcast:
            print("[ERROR] Image broadcast is not supported")
            sys.exit(1)
        success = send_image(args.sender_id, args.target, args.image)
    elif args.broadcast:
        exclude_nodes = set(args.exclude) if args.exclude else set()
        success = broadcast_message(args.sender_id, args.message, exclude_nodes)
    else:
        success = direct_message(args.sender_id, args.target, args.message)

    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()